package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	chatpb "github.com/maehiyu/tollo/gen/go/protos/chatservice"
	userpb "github.com/maehiyu/tollo/gen/go/protos/userservice"
	"github.com/maehiyu/tollo/internal/gateway/graph/model"
)

// GeneralUser is the resolver for the generalUser field.
func (r *chatResolver) GeneralUser(ctx context.Context, obj *model.Chat) (*model.User, error) {
	userRes, err := r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Id{Id: obj.GeneralUserID}})
	if err != nil {
		return nil, err
	}
	return r.Resolver.ProtoUserToGraphQLUser(userRes), nil
}

// ProfessionalUser is the resolver for the professionalUser field.
func (r *chatResolver) ProfessionalUser(ctx context.Context, obj *model.Chat) (*model.User, error) {
	userRes, err := r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Id{Id: obj.ProfessionalUserID}})
	if err != nil {
		return nil, err
	}
	return r.Resolver.ProtoUserToGraphQLUser(userRes), nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*model.Message, error) {
	req := &chatpb.SendMessageRequest{
		ChatId:   input.ChatID,
		SenderId: input.SenderID,
	}

	if input.Standard != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Standard{
			Standard: &chatpb.StandardMessage{Content: input.Standard.Content},
		}
	} else if input.Question != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Question{
			Question: &chatpb.QuestionMessage{Content: input.Question.Content, Tags: input.Question.Tags},
		}
	} else if input.Answer != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Answer{
			Answer: &chatpb.AnswerMessage{Content: input.Answer.Content, QuestionId: input.Answer.QuestionID},
		}
	} else if input.Promotional != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Promotional{
			Promotional: &chatpb.PromotionalMessage{
				Title:     input.Promotional.Title,
				Body:      input.Promotional.Body,
				ActionUrl: input.Promotional.ActionURL,
				ImageUrl:  *input.Promotional.ImageURL,
			},
		}
	} else {
		return nil, fmt.Errorf("message payload is required")
	}

	res, err := r.Resolver.ChatClient.SendMessage(ctx, req)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		ID:       res.SentMessage.Id,
		ChatID:   res.SentMessage.ChatId,
		SenderID: res.SentMessage.SenderId,
		SentAt:   res.SentMessage.SentAt.AsTime(),
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	// 1. Convert GraphQL input to gRPC request
	if input.Professional == nil && input.General == nil {
		return nil, fmt.Errorf("input error: profile is required, either professional or general must be provided")
	}
	req := &userpb.CreateUserRequest{
		Name:  input.Name,
		Email: input.Email,
	}
	if input.Description != nil {
		req.Description = *input.Description
	}

	if input.Professional != nil {
		req.Profile = &userpb.CreateUserRequest_Professional{
			Professional: &userpb.ProfessionalProfile{
				ProBadgeUrl: input.Professional.ProBadgeURL,
				Biography:   input.Professional.Biography,
			},
		}
	} else if input.General != nil {
		req.Profile = &userpb.CreateUserRequest_General{
			General: &userpb.GeneralProfile{
				Points:       uint32(input.General.Points),
				Introduction: input.General.Introduction,
			},
		}
	}

	// 2. Call gRPC client
	res, err := r.Resolver.UserClient.CreateUser(ctx, req)
	if err != nil {
		return nil, err
	}

	return r.Resolver.ProtoUserToGraphQLUser(res), nil
}

// CreateChat is the resolver for the createChat field.
func (r *mutationResolver) CreateChat(ctx context.Context, input model.CreateChatInput) (*model.Chat, error) {
	req := &chatpb.CreateChatRequest{
		GeneralUserId:      input.GeneralUserID,
		ProfessionalUserId: input.ProfessionalUserID,
	}

	res, err := r.Resolver.ChatClient.CreateChat(ctx, req)
	if err != nil {
		return nil, err
	}

	return r.Resolver.ProtoChatToGraphQLChat(res.Chat), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string, email *string) (*model.User, error) {
	var userRes *userpb.UserInfo
	var err error

	if id != nil && *id != "" {
		userRes, err = r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Id{Id: *id}})
	} else if email != nil && *email != "" {
		userRes, err = r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Email{Email: *email}})
	} else {
		return nil, fmt.Errorf("either id or email must be provided")
	}

	if err != nil {
		return nil, err
	}

	return r.Resolver.ProtoUserToGraphQLUser(userRes), nil
}

// UserChats is the resolver for the userChats field.
func (r *queryResolver) UserChats(ctx context.Context, userID string) ([]*model.Chat, error) {
	req := &chatpb.GetUserChatsRequest{
		UserId: userID,
	}

	res, err := r.Resolver.ChatClient.GetUserChats(ctx, req)
	if err != nil {
		return nil, err
	}

	gqlChats := make([]*model.Chat, len(res.Chats))
	for i, protoChat := range res.Chats {
		gqlChats[i] = r.Resolver.ProtoChatToGraphQLChat(protoChat)
	}

	return gqlChats, nil
}

// ChatMessages is the resolver for the chatMessages field.
func (r *queryResolver) ChatMessages(ctx context.Context, chatID string) ([]*model.Message, error) {
	req := &chatpb.GetChatMessagesRequest{
		ChatId: chatID,
	}

	res, err := r.Resolver.ChatClient.GetChatMessages(ctx, req)
	if err != nil {
		return nil, err
	}

	gqlMessages := make([]*model.Message, len(res.Messages))
	for i, protoMsg := range res.Messages {
		gqlMessages[i] = r.Resolver.ProtoMessageToGraphQLMessage(protoMsg)
	}

	return gqlMessages, nil
}

// Chat returns ChatResolver implementation.
func (r *Resolver) Chat() ChatResolver { return &chatResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type chatResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
