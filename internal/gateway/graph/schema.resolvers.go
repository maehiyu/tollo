package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	chatpb "github.com/maehiyu/tollo/gen/go/protos/chatservice"
	userpb "github.com/maehiyu/tollo/gen/go/protos/userservice"
	"github.com/maehiyu/tollo/internal/gateway/graph/model"
)

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*model.Message, error) {
	req := &chatpb.SendMessageRequest{
		ChatId:   input.ChatID,
		SenderId: input.SenderID,
	}

	if input.Standard != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Standard{
			Standard: &chatpb.StandardMessage{Content: input.Standard.Content},
		}
	} else if input.Question != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Question{
			Question: &chatpb.QuestionMessage{Content: input.Question.Content, Tags: input.Question.Tags},
		}
	} else if input.Answer != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Answer{
			Answer: &chatpb.AnswerMessage{Content: input.Answer.Content, QuestionId: input.Answer.QuestionID},
		}
	} else if input.Promotional != nil {
		req.MessagePayload = &chatpb.SendMessageRequest_Promotional{
			Promotional: &chatpb.PromotionalMessage{
				Title:     input.Promotional.Title,
				Body:      input.Promotional.Body,
				ActionUrl: input.Promotional.ActionURL,
				ImageUrl:  *input.Promotional.ImageURL,
			},
		}
	} else {
		return nil, fmt.Errorf("message payload is required")
	}

	res, err := r.Resolver.ChatClient.SendMessage(ctx, req)
	if err != nil {
		return nil, err
	}

	return &model.Message{
		ID:       res.SentMessage.Id,
		ChatID:   res.SentMessage.ChatId,
		SenderID: res.SentMessage.SenderId,
		SentAt:   res.SentMessage.SentAt.AsTime(),
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.User, error) {
	// 1. Convert GraphQL input to gRPC request
	if input.Professional == nil && input.General == nil {
		return nil, fmt.Errorf("input error: profile is required, either professional or general must be provided")
	}
	req := &userpb.CreateUserRequest{
		Name:  input.Name,
		Email: input.Email,
	}
	if input.Description != nil {
		req.Description = *input.Description
	}

	if input.Professional != nil {
		req.Profile = &userpb.CreateUserRequest_Professional{
			Professional: &userpb.ProfessionalProfile{
				ProBadgeUrl: input.Professional.ProBadgeURL,
				Biography:   input.Professional.Biography,
			},
		}
	} else if input.General != nil {
		req.Profile = &userpb.CreateUserRequest_General{
			General: &userpb.GeneralProfile{
				Points:       uint32(input.General.Points),
				Introduction: input.General.Introduction,
			},
		}
	}

	// 2. Call gRPC client
	res, err := r.Resolver.UserClient.CreateUser(ctx, req)
	if err != nil {
		return nil, err
	}

	// 3. Convert gRPC response to GraphQL model
	gqlUser := &model.User{
		ID:        res.Id,
		Name:      res.Name,
		Email:     res.Email,
		CreatedAt: res.CreatedAt.AsTime(),
		UpdatedAt: res.UpdatedAt.AsTime(),
	}

	// Handle the profile oneof from the response
	if profProfile := res.GetProfessionalProfile(); profProfile != nil {
		gqlUser.Profile = &model.ProfessionalProfile{
			ProBadgeURL: profProfile.ProBadgeUrl,
			Biography:   profProfile.Biography,
		}
	} else if genProfile := res.GetGeneralProfile(); genProfile != nil {
		gqlUser.Profile = &model.GeneralProfile{
			Points:       int32(genProfile.Points),
			Introduction: genProfile.Introduction,
		}
	}

	return gqlUser, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string, email *string) (*model.User, error) {
	var userRes *userpb.UserInfo
	var err error

	if id != nil && *id != "" {
		userRes, err = r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Id{Id: *id}})
	} else if email != nil && *email != "" {
		userRes, err = r.Resolver.UserClient.GetUser(ctx, &userpb.GetUserRequest{LookupBy: &userpb.GetUserRequest_Email{Email: *email}})
	} else {
		return nil, fmt.Errorf("either id or email must be provided")
	}

	if err != nil {
		return nil, err
	}

	return &model.User{
		ID:        userRes.Id,
		Name:      userRes.Name,
		Email:     userRes.Email,
		CreatedAt: userRes.CreatedAt.AsTime(),
		UpdatedAt: userRes.UpdatedAt.AsTime(),
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
